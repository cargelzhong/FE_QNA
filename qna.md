## Why not iframe

浏览器原生的样式、js 隔离，隔离性导致应用间上下文无法被共享

1. url 不同步。浏览器刷新 iframe url 状态丢失、后退前进按钮无法使用。
2. UI 不同步，DOM 结构不共享。想象一下屏幕右下角 1/4 的 iframe 里来一个带遮罩层的弹框，同时我们要求这个弹框要浏览器居中显示，还要浏览器 resize 时自动居中..
3. 全局上下文完全隔离，内存变量不共享。iframe 内外系统的通信、数据同步等需求，主应用的 cookie 要透传到根域名都不同的子应用中实现免登效果。
4. 加载慢。每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程

## 双向绑定原理及实现

监听器（Observer）收集监听数据属性，消息订阅器（Dep）收集订阅者，数据发生变化的时候发布消息通知订阅者，然后解析器（Compiler）通知更新视图。 Object 的 definedPorperty() 便利属性值数据劫持，代理所有数据的 getter 和 setter，在 setter 触发时通知订阅者。

## 路由懒加载

()=>import ('../../xxx.vue') 形式，利用函数只有被调用才会执行，打包不同组件至不同 js，只有在进入当前路由才会加载对应的组件。

## vue-router 中 hash 模式和 h5 模式 区别

- 哈希模式：使用了哈希字符 "#" ,`Hash变化不会重新请求向服务器请求` 不需要再服务器层面做配置处理。SEO（搜索引擎优化）中表现较差。hashchange 事件触发
- H5 模式：容易出现刷新页面 404，需要服务端做重定向配置。

## 组件传参方式

- 父传子 props
- 子传父$emit 事件传参
- 共用数据源 vuex
- 事件总线 基于发布订阅模式 $emit $on $off

## cookie，sessionStorage，localStorage，vuex 区别

- cookie 一般是服务器创建后返回给浏览器，告诉浏览器设置 cookie 保存用户的信息。
- sessionStorage 是临时保存，页面被关闭就会清除，被限制在同个窗口，只能存字符串。
- localStorage 以文件形式本地永久保存，只能存字符串。
- vuex 状态管理器更多用于 vue 组件之间传值，多组件使用同一数据源的清空，是响应式的
  根据具体业务情况进行选择

## 什么时候需要函数封装

看过一个比喻，一行行代码就是一个个单词，各种词语组成了清楚表达某种明确含义的句子，就是应该封装函数的时候

## 单页面和非单页面的区别

- 非单页面是多个 html，跳转也是不同 html 间的跳转，首屏加载稍快，传参比较麻烦。
- 单页面就是只有一个 html 页面，较复杂的系统首屏加载会慢一些，一次请求了所有需要的资源，需要做优化处理，优点是加载完成后，页面切换较快，局部刷新用户体验较好。
